<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
/* 1，变量提升
     代码执行先把用var和function 关键字声明的变量提前声明，带var的只声明不定义
     带function 声明又定义，前提是不在块级作用域内；
     
     暂时性死区
      在let  const声明的变量之上；不能使用对应的变量，一经使用就报错，
    2，堆栈内存
     栈内存 存储值内存，提供代码的运行环境；
     堆内存 存储引用数据类型
     对象的存储过程，把键值对，一对一对的存储进去，储存完成之后赋给对应的变量
     函数的村塾过程，先开辟一个堆内存把函数党走字符串存储到该内存中，存储完成之后把地址赋给函数名

    作用域：都是栈内存
     全局作用域：页面一打开就会形成一个全局作用域；window
     私有作用域：函数执行形成的作用域；函数执行额过程：先开辟一个作用域，然后是形参赋值，然后是变量提升 代码执行。
      块状作用域：es6特有，针对let和const能够起作用，对于var 没有任何反应

      全局变量：全局声明的变量；
      私有变量：私有作用域声明的变量，对于函数来说还有形参
      var  let  const  区别？
       1， var可以重复声明，let，const不能重复声明；let是变量，const是常亮
       2， let const 没有变量提升，存在暂时性死区
       3， let const 能够识别块级作用域

    垃圾回收，对栈内村销毁
      堆内存的销毁：谷歌浏览器会定时的查看堆内存空间，把空间中没有被引用的堆内存回收
      栈内存的销毁，全局作用域销毁只有当页面关闭的时候才会销毁
    闭包：一个不销毁的作用域，保护私有变量不受外界的污染。二、存储值
    闭包有什么缺点？
    用的多了，会造成内存泄漏

    3 this 函数的执行主体，谁让这个函数执行了；
        1.时间绑定中的this都是当前的操作元素；
        2，自执行函数中的this 是window
        3，一般函数执行的时候是看点的，点前边是谁，没有点的都是window 
    */
      var a={b:19}
      function f(a){
      a= {b:20};
       console.log(a)
      }
      f()
      console.log(a)



</script>
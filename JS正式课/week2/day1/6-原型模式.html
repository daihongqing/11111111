<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>  
     var ary=[]//字面量的创建方式
     var ary2=new Array()//通过构造函数模式创建
     ary.push(1,2,3)
     ary2.push(4,5,6)
     console.log(ary,ary2)
     //Array  ary2 ary 都是Array的实例

     var Person=function (name,age){
         this.name=name;
         this.age=age;
         this.eat=function (){
             console.log(`${this.name} 吃饭`)
         }
     }
  Person.prototype.play=function (){
   //在Person类的原型上，添加一个play属性；值是一个函数
    console.log('玩')
 }
  var per1=new Person('李四',20)//per1 是Person类的一个实例；person 是一个自定义类
  var per2=new Person('张三',22)
  console.log(per1,per2)
  console.log(per1.eat===per2.eat)//false
  console.log(ary.push===ary.push)//true
  console.log(per1,play)//per1是怎么调到的 play函数？

  console.log(per.__proto__===Person.peototype)//true

 
 console.log(per1)
  /*
   原型：prototype  就是一块堆内存
   每一个实例都有一个_proto_的属性，指向所属类的原型
   每一个函数都有一个prototype的属性，指向自己的原型
   每一个类的原型上都有一个constructor属性，指向所有类（函数本身）
   */
var f=function (){
    console.log(666)
 }
 console.log(f.prototype)

 /* 作用域链：变量的查找机制，先看变量是不是自己私有的  不是的话就去上级作用域查找 
 原型链：属性的查找机制，仙子啊自己身上查找，没有的话 就通过——proto——向自己所属的原型上查找*/

</script>